<?xml version="1.0" encoding="utf-8"?>
<!--
  //////////////////////////////////////////////////////////////////
  // Copyright (c) 2008-2013 Esri. All Rights Reserved.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //    http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.
  ////////////////////////////////////////////////////////////////
-->
<!--- The default skin class for Spark TextInput component.

@see spark.components.TextInput

@langversion 3.0
@playerversion Flash 10
@playerversion AIR 1.5
@productversion Flex 4
-->
<s:SparkSkin xmlns:fx="http://ns.adobe.com/mxml/2009"
             xmlns:s="library://ns.adobe.com/flex/spark"
             xmlns:fb="http://ns.adobe.com/flashbuilder/2009"
             alpha.disabled="0.5"
             blendMode="normal">

    <fx:Metadata>
        <![CDATA[ 
			/** 
			* @copy spark.skins.spark.ApplicationSkin#hostComponent
			*/
			[States("normalWithPrompt",  "disabledWithPrompt")]
			[HostComponent("widgets.Portal.components.PromptTextInput")]
		]]>
    </fx:Metadata>

    <fx:Script fb:purpose="styling">
        private var paddingChanged:Boolean;

        /* Define the skin elements that should not be colorized. */
        static private const exclusions:Array = [ "background", "textDisplay" ];

        /**
         * @private
         */
        override public function get colorizeExclusions():Array
        {
            return exclusions;
        }

        /* Define the content fill items that should be colored by the "contentBackgroundColor" style. */
        static private const contentFill:Array = [ "bgFill" ];

        /**
         *  @private
         */
        override public function get contentItems():Array
        {
            return contentFill
        };

        /**
         *  @private
         */
        override protected function commitProperties():void
        {
            super.commitProperties();

            if (paddingChanged)
            {
                updatePadding();
                paddingChanged = false;
            }
        }

        /**
         * @private
         */
        override protected function initializationComplete():void
        {
            useChromeColor = true;
            super.initializationComplete();
        }

        /**
         *  @private
         */
        override protected function updateDisplayList(unscaledWidth:Number, unscaledHeight:Number):void
        {
            if (getStyle("borderVisible") == true)
            {
                border.visible = true;
                shadow.visible = true;
                background.left = background.top = background.right = background.bottom = 1;
                textDisplay.left = textDisplay.top = textDisplay.right = textDisplay.bottom = 1;
            }
            else
            {
                border.visible = false;
                shadow.visible = false;
                background.left = background.top = background.right = background.bottom = 0;
                textDisplay.left = textDisplay.top = textDisplay.right = textDisplay.bottom = 0;
            }

            borderStroke.color = getStyle("borderColor");
            borderStroke.alpha = getStyle("borderAlpha");

            super.updateDisplayList(unscaledWidth, unscaledHeight);
        }

        /**
         *  @private
         */
        private function updatePadding():void
        {
            if (!textDisplay)
            {
                return;
            }

            // Push padding styles into the textDisplay
            var padding:Number;

            padding = getStyle("paddingLeft");
            if (textDisplay.getStyle("paddingLeft") != padding)
            {
                textDisplay.setStyle("paddingLeft", padding);
            }

            padding = getStyle("paddingTop");
            if (textDisplay.getStyle("paddingTop") != padding)
            {
                textDisplay.setStyle("paddingTop", padding);
            }

            padding = getStyle("paddingRight");
            if (textDisplay.getStyle("paddingRight") != padding)
            {
                textDisplay.setStyle("paddingRight", padding);
            }

            padding = getStyle("paddingBottom");
            if (textDisplay.getStyle("paddingBottom") != padding)
            {
                textDisplay.setStyle("paddingBottom", padding);
            }
        }

        /**
         *  @private
         */
        override public function styleChanged(styleProp:String):void
        {
            var allStyles:Boolean = !styleProp || styleProp == "styleName";

            super.styleChanged(styleProp);

            if (allStyles || styleProp.indexOf("padding") == 0)
            {
                paddingChanged = true;
                invalidateProperties();
            }
        }
    </fx:Script>

    <fx:Script>
        <![CDATA[
            protected function showPrompt(state:String, text:String):Boolean
            {
                return (state != "focused" && text == "");
            }
        ]]>
    </fx:Script>

    <s:states>
        <s:State name="normal"/>
        <s:State name="disabled"/>
        <s:State name="focused"/>
    </s:states>

    <!-- border -->
    <!--- @private -->
    <s:Rect id="border"
            left="0" right="0" top="0" bottom="0">
        <s:stroke>
            <!--- @private -->
            <s:SolidColorStroke id="borderStroke" weight="1"/>
        </s:stroke>
    </s:Rect>

    <!-- fill -->
    <!--- Defines the appearance of the TextInput component's background. -->
    <s:Rect id="background"
            left="1" right="1" top="1" bottom="1">
        <s:fill>
            <!--- @private Defines the background fill color. -->
            <s:SolidColor id="bgFill"/>
        </s:fill>
    </s:Rect>

    <!-- shadow -->
    <!--- @private -->
    <s:Rect id="shadow"
            height="1"
            left="1" right="1" top="1">
        <s:fill>
            <s:SolidColor alpha="0.12" color="{getStyle('color')}"/>
        </s:fill>
    </s:Rect>

    <!-- text -->
    <!--- @copy spark.components.supportClasses.SkinnableTextBase#textDisplay -->
    <s:RichEditableText id="textDisplay"
                        left="1" right="1" top="1" bottom="1"
                        verticalAlign="middle"
                        widthInChars="10"/>
    <s:Label id="promptView"
             left="1" right="1" top="1" bottom="1"
             color="{getStyle('color')}"
             lineBreak="explicit"
             paddingBottom="3"
             paddingLeft="3"
             paddingRight="3"
             paddingTop="5"
             text="{hostComponent.promptText}"
             visible="{showPrompt(currentState, hostComponent.text)}"/>
</s:SparkSkin>
